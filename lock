mysql 悲观锁和乐观锁

悲观锁：
 从开始就认为我要操作的数据会被其他人修改，所以一开始我就给他加锁，直到我完成修改，其他人才能继续操作，一般是由数据库机制。

乐观锁：
 
 认为这条数据，操作的人很少，可能只有我在操作，所以给表加个标识，在对数据库进行处理的时候，并不会使用sql提供的锁机制，只有在写入时采取判断这个标识和数据库的是不是一致，如果一致说明没人修改，不一致说明已经被人修改了，我这个操作回滚返回失败。
 乐观锁存在失效的情况，属小概率事件
 只在提交操作时检查。 乐观锁不能解决脏读的问题
 
 使用时机：
   如果并发写不多，可以用乐观锁，不然失败的几率会很大，其他建议使用悲观锁。
   在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法
   
   使用悲观锁需要关闭sql的自动提交
     set autocommit = false
     以后所有的操作都放在一个事物中
     begin;/begin work;/start transaction; (三者选一就可以)
     select x from xx where x =xx for update  
     (事物中只有该样式这条数据才会使用锁，如果有其他程序需要该数据，只能等待该事物结束，才可以进行，
     如果其他程序不加 for update 则不受该事物影响，可以查询到数据)
     xxxx
     xxxxx
     commit;/commit work;
     
     
     锁的级别：
     innodb 默认行级锁，但是如果没有明确主键，则会使用表级锁。
     
     主键对表锁影响
     
     1:明确指定主键，并且有数据 为 行级锁,其他代码查询会堵塞，如果时间太长会提示错误。 select * from t_goods where id=1 for update;
     2:明确指定主键，没有数据，没有锁
     3:无主键，为 表锁，select * from t_goods where name='道具' for update; （name为道具的可能很多）
     4：主键不明确，为表锁 select * from t_goods where id>1 for update;
     
     索引对表锁影响
     
     1：明确指定索引，并且有数据，为 行锁 ，其他代码查询该数据会堵塞，超时会返回空 select * from t_goods where status=1 for update; status加了索引
     2：明确指定索引，没有数据，没有锁
     
     innodb 如果查询不使用索引或明确主键，为 表锁
     
     
