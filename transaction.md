[toc]
# mysql事务、锁、隔离级别
## 事务
> 事务
对数据库进行操作的一系列操作的集合具有ACID属性
### 特性
> ACID特性由数据库管理系统来实现。
acd 由日志来保证，日志记录了事务对数据库所有的更改，如果摸个事务执行发生错误，就可以更具日志撤销事务对数据的所有更改，退回到事务执行前的状态。
i由数据库管理系统采用锁机制来实现，当多个事物同时更新相同数据，只有允许持有锁的事务对该数据进行更新，其他事务等待，直到前一个事务释放锁，其他事务才有机会更新该数据。
### 原子性（atomicity）
> 一个事务被视为不可分割的最小工作单元，整个事物中的操作要么全部成功，要么全部失败。
### 一致性（consistency）
> 数据总是从一个一致性转换到另外一个一致性，比如转账a减100，那么b必须加一百，总金额不会少100始终保持最终一致性。要么在a，要么在b，数据原有的一致不会被打破。
### 隔离性（isolation）
> 一个事务的执行不会影响到另外其他的事务，对其他事务不可见，具体表现形式更具不同的隔离级别表现形式不一样。
### 持久性（durability）
> 事务提交，数据库永久保持更改。

## 锁
> 锁
为了解决数据库并发时，保证数据的一致性，而对并发进行控制的一种机制。
ex. 同一条数据有多个客户端在操作，A 读取操作，b 修改操作，c 去删除。

### 锁分类
> 从类型分

- 悲观锁：从开始就认为我要操作的数据会被其他人修改，所以一开始我就给他加锁，直到我完成修改，其他人才能继续操作，一般是由数据库层提供锁机制，才能真正保证数据访问的排他性。
使用悲观锁需要关闭sql的自动提交，` set autocommit = false`,并且需要手动commit 提交.

- 乐观锁：认为这条数据，操作的人很少，可能只有我在操作，大多是基于数据版本（version）记录机制实现。数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

> 从对数据操作类型（读、写）分

- 读锁（共享锁）：同一块数据，多个读操作同时进行，互相不会受影响
- 写锁（排他锁）：当前操作没有完成前会阻止其他写锁和读锁进行，等待或超时


### 锁粒度
> 为了提升数据库的并发量，锁住的数据越少越好，
加锁也需要消耗资源，包括获得锁，检查锁，是否解除，释放锁。锁策略就是在锁开销和数据安全之间寻求平衡。为了在并发量和系统性能之间平衡，产生了锁粒度。

- 表锁：开销小，加锁快，粒度大，不会出现死锁，锁冲突概率最大，并发量也最小。myiasm存储引擎使用。当写入时整个表锁定，任何其他写、读锁都是等待中。写锁比读锁有更高的优先级，因此写锁可能会被插入到读锁队列前面执行。
- 行锁：并发量最大，开销也最大，锁粒度小，锁冲突概率最小。innodb使用这种策略。
 > 但是如果没有明确主键，则会使用表级锁,

- 页面锁：开销和加锁时间以及粒度介于表锁和行锁之间，并发度一般。

### 死锁
> 两个或多个事务在执行过程中，发生争夺资源而互相等待的一个现象。若无外力作用，发生互相等待的进程就是死锁进程。表级锁不会出现死锁，死锁主要发生在innodb引擎中。
死锁的关键在于两个或多个session加锁的顺序不一致，解决就是让加锁有序。（不是太明白）

- innodb 处理死锁方法，将持有最少行级排它锁的事务回滚。

###锁协议
> mysql数据库遵循的是两段锁协议，将事务分成两个阶段，加锁和解锁阶段。

- 加锁：事务开始后对数据进行的任何操作加锁，读操作时申请共享锁，其他事务可以加共享锁，但不能加排他锁。写操作申请排他锁，其他事务不能获得任何锁，加锁不成功，事物进入等待阶段，直到加锁成功在继续，或等待超时。
- 解锁：当事务提交时，同时释放锁

### 索引和主键对锁影响
> innodb 默认行级锁,如果查询不使用索引或明确主键，为 表锁

- 明确指定主键，并且有数据 为 行级锁,其他代码查询会堵塞
- 明确指定主键，没有数据，没有锁
- 无主键，为 表锁
- 主键不明确，为表锁
- 明确指定索引，并且有数据，为 行锁 ，其他代码查询该数据会堵塞
- 明确指定索引，没有数据，没有锁

## 事务隔离

> 

|隔离级别|脏读|更新丢失|不可重复读|幻读|并发模型|
|--------|:------:|------|---------|------|-------:|
|未提交读`read uncommitted`|是|是|是|是|悲观|
|已提交读`read committed`|否|是|是|是|悲观|
|可重复读`repeatbale read`|否|否|否|是|悲观|
|可串行读`serializable`|否|否|否|否|悲观|

> 大多数数据库使用的`read committed`，mysql默认使用的是`repeatable read` 从5.5开始存储引擎默认innodb。建议使用innodb，不在使用myiasm。

### 更改事务隔离级别
> global 设置全局默认隔离级别，session只设置这次打开的cmd窗口中的所有事务隔离级别，并在当前这个事务中生效，在打开一个cmd不受影响。如果不设置则为设置本次命令及以后的隔离级别，如果下个事务没有使用set设置会调用默认隔离级别。
> 看`read committed ` 和 `read uncommitted`的效果需要关掉autocommit，否则sql语句运行会自动隐式的执行commit

```mysql
select @@autocommit;#查看autocommit变量设置
set autocommit = 0;#关闭自动事务提交
use test;
select @@tx_isolation;#查看当前会话的隔离级别
select @@global.tx_isolation;#查看mysql系统的事务隔离级别
set [global|session] transaction isolation level read uncommitted | read committed | repeatable | serializable
```
### 脏读
- a事务读取了b事务未提交的数据，b如果回滚，a事务出现错误

![](./zangdu.png)

### 不可重复读
- a事务先后执行了两个相同的查询，但是结果不一致，因为该数据被b事务修改并提交，导致a事务先后相同查询结果不一致。

![](./bukechongfudu.png)

### 幻读
- a事务修改具有摸个相同属性的批量数据，b事务此时写入该属性的一条新数据，a事务查询修改发现有一条数据没有被更改，出现幻觉。

![](./huandu.png)

### 数据丢失更新
> a，b事务同时读取一条数据，a先修改并提交，b也修改（不知道a修改过），b提交后覆盖a事务修改。

### 未提交读
> 对任何操作都不解锁，基本不用。

- 所有事务都能看到其他事务未提交的执行结果。

### 提交读
> 大多数数据库默认级别（oracle等），mysql除外，读不加锁，写，修改，删除加排他锁，where语句中如果没有主键或主键不明确，或没有使用索引会使用表锁，否则为行锁。
表锁很影响性能，mysql做了优化，当引擎对表加锁时，mysql server会在过滤条件时，释放不满足条件的锁。保证最后只有满足条件的数据加锁，但是加锁过程还是在的，因此会发生并未被修改的数据被加锁。

### 可重复读
> 同一事务相同查询得到结果不受其他事务影响，始终保持一致，但是存在幻读。mysql默认级别，innodb引擎默认级别，innodb使用mvcc多版本并发控制协议（以乐观锁为理论基础）避免了幻读。

- 不可重复读，和幻读区别，不可重复读主要影响在update，delete ，幻读影响在insert。
- innodb 在开启事务时获取隐式锁，显式锁`select ... for update`,不建议显式的执行锁操作。

### 可串行读
> 读加共享锁，写加排它锁，读写锁互斥。保证所有事务串行执行，完全避免了脏读，不可重复读，幻读，更新丢失。并发很差，如果并发少或者对数据要求及时可靠，可以使用。会出现很多超时现象和锁竞争。

## innodb引擎加锁机制
> 事务的隔离级别其实都是对于读数据的定义（其实也可以说定义了写的定义），mvcc让数据变的可以重复读，那么有可能读到的里是历史数据，不是当前数据。对于数据失效性要求高的可能会出现问题。mysql为了提升并发性，减少锁处理时间，引入了快照读，使 `select` 这样的可以不加锁，直接读快照。而 `insert` `update` `delete` 等当前读，为了解决当前读出现幻读引入了next-key锁。
读可以分为两种：

- 快照读：读取历史数据的方式。
    `select`
- 当前读：读取和处理数据库当前版本数据的方式，需要加锁。
    `select .... for update` `insert` `update` `delete`

### MVCC
>  mvcc只是个协议，没有固定的实现规范，每个数据库实现的都可以不一样，mvcc只在repeatable read 和read commited隔离级别有效， innodb的实现算不上真正实现了mvcc，mvcc本质使用乐观锁实现多版本共存，mysql使用了两段锁协议，本质是锁，乐观锁本质是消除锁，两者矛盾，故理想的mvcc是很难实现的。innodb只是借了mvcc名字实现了非堵塞的读而已。

#### 原理
> 每次开启一个事务都会生成一个新的事务版本号，且为递增。通过保持时间快照和读取快照来实现当同一个事务相同一个操作始终能看到相同数据，反之意味着同一时刻不同事务看到的数据可能不一致。

#### 特征
> 每行数据都有一个版本，每次数据更新都同时更新版本号。
修改是copy出当前数据，各个事务之间不干扰。
保存时比较版本号，如果成功（commit），则覆盖记录，否则放弃copy修改（rollback）

#### innodb对于mvcc的实现策略
 > 每行数据有两个单独隐藏的列，当前行创建时的版本号，何时删除的版本号或过期的版本号（可能为空），存的版本号并不是时间戳，而是事务的版本号，每开启一个事务，事务会使用该版本号作为该事务自己的版本号，同时版本号开始递增。当事务进行curd时通过版本号的比较来达到数据版本控制的目的。
 
#### 具体操作（在repeatable read 级别 innodb引擎）
- `select` 读取创建版本号 <= 当前事务版本号，删除版本号为空或 >当前事务版本号。
- `insert` 保存当前事务版本号为行的创建版本号
- `delete` 保存当前事务版本号为行的删除版本号
- `update` 插入一条记录，同时保存当前事务版本号为行创建版本号，当前事务版本号为行删除版本号。

> 保存这两个额外的版本号，可大部分操作不需要加锁，减少锁的使用。读数据操作很简单，性能更好，并且也能保证只读取到符合条件的行，也只锁住必要的行。不足之处在于需要额外的空间，以及更多的行检查操作和一些额外的维护工作。

### GAP（间隙锁）
- 如果查询字段使用了索引，如多条数据 user_id分别为 10，13，17，19
此时更新符合wehre 条件 user_id = 13的数据，innodb会将数据分区，无穷小-10，10-13，13-17，17-19，19到无穷大，此时会锁住10-13和13-17这个区间使数据无法插入。
- 如果查询条件没有使用索引会给全表加锁，同时他不会向提交读隔离级别mysql server会过滤解除不满足查询查询的数据锁，除非事务提交，否则其他事务无法插入任何数据。

### Next-Key 锁
>Next-Key锁为行锁和Gap的合并。
 行锁可以防止不同事务版本的数据修改提交时造成数据冲突，
 gap防止别的事务新增，
 所以next-key解决了rr级别的隔离出现的幻读问题。
 
[参考1](http://blog.csdn.net/xifeijian/article/details/45230053)
[参考2](https://tech.meituan.com/innodb-lock.html)
[参考3](https://my.oschina.net/xinxingegeya/blog?catalog=457778&temp=1516244652916)
